<!DOCTYPE html>
<html>
    <head>
        <title>nearley.js - JS Parsing Toolkit</title>
        <meta charset="utf-8"/>
        <meta name="description" content="nearley.js is a simple, fast, and powerful parser toolkit for JavaScript." />
        <link href='https://fonts.googleapis.com/css?family=Roboto:300,700'
              rel='stylesheet' type='text/css'/>
        <link rel="stylesheet" type="text/css" href="/www/main.css"/>
        <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script>
    </head>
    <body>
        <a href="https://github.com/Hardmath123/nearley" class="github-corner"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
        <div id="main" class="center">
            <h1><a href="/">nearley<span style="color: #559;">.js</span><span id="version">2.10.4</span></a></h1>
<h2 id="installation">Installation</h2>
<p>The nearley <em>compiler</em> converts grammar definitions from a simple
<a href="https://en.wikipedia.org/wiki/Backus–Naur_form">BNF</a>-based syntax to a small
JS module. You can use that module to construct a nearley <em>parser</em>, which
parses input strings.</p>
<p>Both components are published as a single
<a href="https://docs.npmjs.com/getting-started/what-is-npm">NPM</a> package compatible
with <a href="https://nodejs.org/en/">Node.js</a> and most browsers.</p>
<p>To use the nearley <em>parser</em>, you need to install nearley <strong>locally</strong>.</p>
<pre><code class="lang-bash">$ npm install --save nearley
</code></pre>
<p>To use the nearley <em>compiler</em>, you need to <em>additionally</em> install nearley
<strong>globally</strong>.</p>
<pre><code class="lang-bash">$ npm install -g nearley
</code></pre>
<p>This actually adds several new commands to your <code>$PATH</code>:</p>
<ul>
<li><code>nearleyc</code> compiles grammar files to JavaScript.</li>
<li><code>nearley-test</code> lets you quickly test a grammar against some input and see the
results. It also lets you explore the internal state of nearley’s Earley
table, in case you find that interesting.</li>
<li><code>nearley-unparse</code> inverts a parser into a generator, allowing you to create
random strings that match your grammar.</li>
<li><code>nearley-railroad</code> generates pretty railroad diagrams from your parser. This
is mainly helpful for creating documentation, as (for example) on json.org.</li>
</ul>
<p>These are documented below.</p>
<blockquote>
<p>NOTE: If you’re not ready to install nearley yet, you can follow along in
your browser using the <a href="https://omrelli.ug/nearley-playground/">nearley
playground</a>, an online interface for
exploring nearley grammars interactively.</p>
</blockquote>
<h2 id="getting-started-nearley-in-3-steps">Getting started: nearley in 3 steps</h2>
<p>nearley was written with users in mind: getting started with nearley is as
simple as:</p>
<p><strong>Step 1: Describe your grammar</strong> using the nearley syntax. In a file called
<code>grammar.ne</code>, write:</p>
<pre><code class="lang-js">main -&gt; (statement &quot;\n&quot;):+
statement -&gt; &quot;foo&quot; | &quot;bar&quot;
</code></pre>
<p><strong>Step 2: Compile</strong> the grammar to a JavaScript module. On the command line,
run:</p>
<pre><code class="lang-bash">$ nearleyc grammar.ne -o grammar.js
</code></pre>
<p><strong>Step 3: Parse</strong> some data! In a new JavaScript file, write:</p>
<pre><code class="lang-js">const nearley = require(&quot;nearley&quot;);
const grammar = require(&quot;./grammar.js&quot;);

// Create a Parser object from our grammar.
const parser = new nearley.Parser(nearley.Grammar.fromCompiled(grammar));

// Parse something!
parser.feed(&quot;foo\n&quot;);

// parser.results is an array of possible parsings.
console.log(parser.results); // [[[[ &quot;foo&quot; ],&quot;\n&quot; ]]]
</code></pre>
<h2 id="writing-a-parser-the-nearley-grammar-language">Writing a parser: the nearley grammar language</h2>
<p>This section describes the nearley grammar language, in which you can describe
grammars for nearley to parse. Grammars are conventionally kept in <code>.ne</code> files.
You can then use <code>nearleyc</code> to compile your <code>.ne</code> grammars to JavaScript
modules.</p>
<p>You can find many examples of nearley grammars online, as well as some in the
<code>examples/</code> directory of the <a href="http://github.com/Hardmath123/nearley">Github
repository</a>.</p>
<h3 id="vocabulary">Vocabulary</h3>
<ul>
<li>A <em>terminal</em> is a string or a token. For example, the keyword <code>&quot;if&quot;</code> is a
terminal.</li>
<li>A <em>nonterminal</em> is a combination of terminals and other nonterminals. For
example, an if statement defined as <code>&quot;if&quot; condition statement</code> is a
nonteminal.</li>
<li>A <em>rule</em> (or production rule) is a definition of a nonterminal. For example,
<code>ifStatement -&gt; &quot;if&quot; condition &quot;then&quot; statement &quot;endif&quot;</code> is the rule
according to which the if statement nonterminal is parsed.</li>
</ul>
<p>By default, nearley attempts to parse the first nonterminal defined in the
grammar. In the following grammar, nearley will try to parse input text as an
<code>expression</code>.</p>
<pre><code class="lang-js">expression -&gt; number &quot;+&quot; number
expression -&gt; number &quot;-&quot; number
expression -&gt; number &quot;*&quot; number
expression -&gt; number &quot;/&quot; number
number -&gt; [0-9]:+
</code></pre>
<p>You can use the pipe character <code>|</code> to separate alternative rules for a
nonterminal. In the example below, <code>expression</code> has four different rules.</p>
<pre><code class="lang-js">expression -&gt;
      number &quot;+&quot; number
    | number &quot;-&quot; number
    | number &quot;*&quot; number
    | number &quot;/&quot; number
</code></pre>
<p>The keyword <code>null</code> stands for the <strong>epsilon rule</strong>, which matches nothing. The
following nonterminal matches zero or more <code>cow</code>s in a row, such as
<code>cowcowcow</code>:</p>
<pre><code class="lang-js">a -&gt; null | a &quot;cow&quot;
</code></pre>
<h3 id="postprocessors">Postprocessors</h3>
<p>By default, nearley wraps everything matched by a rule into an array. For
example, when <code>rule -&gt; &quot;foo&quot; &quot;bar&quot;</code> matches, it creates the “parse tree”
<code>[&quot;foo&quot;, &quot;bar&quot;]</code>.  Most of the time, however, you need to process that data in
some way: for example, you may want to filter out whitespace, or transform the
results into a custom JavaScript object.</p>
<p>For this purpose, each rule can have a <em>postprocessor</em>: a JavaScript function
that transforms the array and returns a “processed” version of the result.
Postprocessors are wrapped in <code>{% %}</code>:</p>
<pre><code class="lang-js">expression -&gt; number &quot;+&quot; number {%
    function(data, location, reject) {
        return {
            operator: &quot;sum&quot;,
            leftOperand: data[0],
            rightOperand: data[2] // data[1] is &quot;+&quot;
        };
    }
%}
</code></pre>
<p>The rule above will parse the string <code>5+10</code> into <code>{ operator: &quot;sum&quot;,
leftOperand: &quot;5&quot;, rightOperand: &quot;10&quot; }</code>.</p>
<p>The postprocessor can be any function. It will be passed three arguments:</p>
<ul>
<li><code>data: Array</code> - an array that contains the results of parsing each part of
the rule. Note that it is still an array, even if the rule only has one part!
You can use the built-in <code>{% id %}</code> postprocessor to convert a one-item array
into the item itself.</li>
<li><code>location: number</code> - the index (zero-based) at which the rule match starts.
This is useful, for example, to construct an error message that tells you where
in the source the error occurred.</li>
<li><code>reject: Object</code> - return this object to signal that this rule doesn’t
<em>actually</em> match. This is necessary in certain edge-conditions. For example,
suppose you want sequences of letters to match variables, except for the
keyword <code>var</code>. In this case, your rule may be<pre><code class="lang-js">word -&gt; [a-z]:+ {%
    function(d,l, reject) {
        if (d[0] == &#39;var&#39;) {
            return reject;
        } else {
            return {&#39;var&#39;: d[0]};
        }
    }
%}
</code></pre>
Please note that grammars using <code>reject</code> are not context-free, and are often
much slower to parse. Use it wisely! You can usually avoid the need for
<code>reject</code> by using a <a href="#tokenizers">tokenizer</a>.</li>
</ul>
<p>Remember that a postprocessor is scoped to a single rule, not the whole
nonterminal. If a nonterminal has multiple alternative rules, each of them can
have its own postprocessor.</p>
<p>For arrow-function users, a convenient pattern is to decompose the <code>data</code> array
within the argument of the arrow function:</p>
<pre><code class="lang-js">expression -&gt;
      number &quot;+&quot; number {% ([first, _, second]) =&gt; first + second %}
    | number &quot;-&quot; number {% ([first, _, second]) =&gt; first - second %}
    | number &quot;*&quot; number {% ([first, _, second]) =&gt; first * second %}
    | number &quot;/&quot; number {% ([first, _, second]) =&gt; first / second %}
</code></pre>
<p>There are two built-in postprocessors for the most common scenarios:</p>
<ul>
<li><code>id</code> - returns the first element of the <code>data</code> array. This is useful to
extract the content of a single-element array: <code>foo -&gt; bar {% id %}</code></li>
<li><code>nuller</code> - returns null. This is useful for whitespace rules: <code>space -&gt; &quot; &quot;
{% nuller %}</code></li>
</ul>
<h4 id="target-languages">Target languages</h4>
<p>By default, <code>nearleyc</code> compiles your grammar to JavaScript. You can also choose
CoffeeScript or TypeScript by adding <code>@preprocessor coffee</code> or <code>@preprocessor
typescript</code> at the top of your grammar file. This can be useful to write your
postprocessors in a different language, and to get type annotations if you wish
to use nearley in a statically typed dialect of JavaScript.</p>
<h3 id="more-syntax-tips-and-tricks">More syntax: tips and tricks</h3>
<h4 id="comments">Comments</h4>
<p>Comments are marked with ‘#’. Everything from <code>#</code> to the end of a line is
ignored:</p>
<pre><code class="lang-ini">expression -&gt; number &quot;+&quot; number # sum of two numbers
</code></pre>
<h4 id="charsets">Charsets</h4>
<p>You can use valid RegExp charsets in a rule (unless you’re using a
<a href="#tokenizers">tokenizer</a>):</p>
<pre><code>not_a_letter -&gt; [^a-zA-Z]
</code></pre><p>The <code>.</code> character can be used to represent any character.</p>
<h4 id="case-insensitive-string-literals">Case-insensitive string literals</h4>
<p>You can create case-insensitive string literals by adding an <code>i</code> after the
string literal:</p>
<pre><code>cow -&gt; &quot;cow&quot;i # matches CoW, COW, and so on.
</code></pre><p>Note that if you are using a lexer, your lexer should use the <code>i</code> flag in its
regexes instead. That is, if you are using a lexer, you should <em>not</em> use the
<code>i</code> suffix in nearley.</p>
<h4 id="ebnf">EBNF</h4>
<p>nearley supports the <code>*</code>, <code>?</code>, and <code>+</code> operators from
<a href="https://en.wikipedia.org/wiki/Extended_Backus–Naur_form">EBNF</a> as shown:</p>
<pre><code class="lang-ini">batman -&gt; &quot;na&quot;:* &quot;batman&quot; # nananana...nanabatman
</code></pre>
<p>You can also use capture groups with parentheses. Its contents can be anything
that a rule can have:</p>
<pre><code class="lang-js">banana -&gt; &quot;ba&quot; (&quot;na&quot; {% id %} | &quot;NA&quot; {% id %}):+
</code></pre>
<h3 id="macros">Macros</h3>
<p>Macros allow you to create polymorphic rules:</p>
<pre><code class="lang-ini"># Matches &quot;&#39;Hello?&#39; &#39;Hello?&#39; &#39;Hello?&#39;&quot;
main -&gt; matchThree[inQuotes[&quot;Hello?&quot;]]

matchThree[X] -&gt; $X &quot; &quot; $X &quot; &quot; $X

inQuotes[X] -&gt; &quot;&#39;&quot; $X &quot;&#39;&quot;
</code></pre>
<p>Macros are dynamically scoped, which means they see arguments passed to parent
macros:</p>
<pre><code class="lang-ini"># Matches &quot;Cows oink.&quot; and &quot;Cows moo!&quot;
main -&gt; sentence[&quot;Cows&quot;, (&quot;.&quot; | &quot;!&quot;)]

sentence[ANIMAL, PUNCTUATION] -&gt; animalGoes[(&quot;moo&quot; | &quot;oink&quot; | &quot;baa&quot;)] $PUNCTUATION

animalGoes[SOUND] -&gt; $ANIMAL &quot; &quot; $SOUND # uses $ANIMAL from its caller
</code></pre>
<p>Macros are expanded at compile time and inserted in places they are used. They
are not “real” rules. Therefore, macros <em>cannot</em> be recursive (<code>nearleyc</code> will
go into an infinite loop trying to expand the macro-loop).</p>
<h3 id="additional-js">Additional JS</h3>
<p>For more intricate postprocessors, or any other functionality you may need, you
can include chunks of JavaScript code between production rules by surrounding
it with <code>@{% ... %}</code>:</p>
<pre><code class="lang-js">@{%
const cowSays = require(&quot;./cow.js&quot;);
%}

cow -&gt; &quot;moo&quot; {% ([moo]) =&gt; cowSays(moo) %}
</code></pre>
<p>Note that it doesn’t matter where you add these; they all get hoisted to the
top of the generated code.</p>
<h3 id="importing-other-grammars">Importing other grammars</h3>
<p>You can include the content of other grammar files:</p>
<pre><code class="lang-ini">@include &quot;../misc/primitives.ne&quot; # path relative to file being compiled
sum -&gt; number &quot;+&quot; number # uses &quot;number&quot; from the included file
</code></pre>
<p>There are several builtin helper files that you can include:</p>
<pre><code class="lang-ini">@builtin &quot;cow.ne&quot;
main -&gt; cow:+
</code></pre>
<p>See the <a href="builtin"><code>builtin/</code></a> directory for more details. Contributions are
welcome!</p>
<p>Including a file imports <em>all</em> of the nonterminals defined in it, as well as
any JS, macros, and configuration options defined there.</p>
<h2 id="using-a-parser-the-nearley-api">Using a parser: the nearley API</h2>
<p>Once you have compiled a <code>grammar.ne</code> file to a <code>grammar.js</code> module, you can
then use nearley to instantiate a <code>Parser</code> object.</p>
<p>First, import nearley and your grammar.</p>
<pre><code class="lang-js">const nearley = require(&quot;nearley&quot;);
const grammar = require(&quot;./grammar.js&quot;);
</code></pre>
<p>Note that if you are parsing in the browser, you can simply include
<code>nearley.js</code> and <code>grammar.js</code> in <code>&lt;script&gt;</code> tags.</p>
<p>Next, use the grammar to create a new <code>nearley.Parser</code> object.</p>
<pre><code class="lang-js">// Create a Parser object from our grammar.
const parser = new nearley.Parser(nearley.Grammar.fromCompiled(grammar));
</code></pre>
<p>Once you have a <code>Parser</code>, you can <code>.feed</code> it a string to parse. Since nearley
is a <em>streaming</em> parser, you can feed strings more than once. For example, a
REPL might feed the parser lines of code as the user enters them:</p>
<pre><code class="lang-js">// Parse something!
parser.feed(&quot;if (true) {&quot;);
parser.feed(&quot;x = 1&quot;);
parser.feed(&quot;}&quot;);
// or, parser.feed(&quot;if (true) {x=1}&quot;);
</code></pre>
<p>Finally, you can query the <code>.results</code> property of the parser.</p>
<pre><code class="lang-js">// parser.results is an array of possible parsings.
console.log(parser.results);
// [{&#39;type&#39;: &#39;if&#39;, &#39;condition&#39;: ..., &#39;body&#39;: ...}]
</code></pre>
<h3 id="a-note-on-ambiguity">A note on ambiguity</h3>
<p>Why is <code>parser.results</code> an array? Sometimes, a grammar can parse a particular
string in multiple different ways. For example, the following grammar parses
the string <code>&quot;xyz&quot;</code> in two different ways.</p>
<pre><code class="lang-js">x -&gt; &quot;xy&quot; &quot;z&quot;
   | &quot;x&quot; &quot;yz&quot;
</code></pre>
<p>Such grammars are <em>ambiguous</em>. nearley provides you with <em>all</em> the parsings. In
most cases, however, your grammars should not be ambiguous (parsing ambiguous
grammars is inefficient!). Thus, the most common usage is to simply query
<code>parser.results[0]</code>.</p>
<h3 id="catching-errors">Catching errors</h3>
<p>nearley is a <em>streaming</em> parser: you can keep feeding it more strings. This
means that there are two error scenarios in nearley.</p>
<p>Consider the simple parser below for the examples to follow.</p>
<pre><code class="lang-js">main -&gt; &quot;Cow goes moo.&quot; {% function(d) {return &quot;yay!&quot;; } %}
</code></pre>
<p>If there are no possible parsings given the current input, but in the <em>future</em>
there <em>might</em> be results if you feed it more strings, then nearley will
temporarily set the <code>results</code> array to the empty array, <code>[]</code>.</p>
<pre><code class="lang-js">parser.feed(&quot;Cow &quot;);  // parser.results is []
parser.feed(&quot;goes &quot;); // parser.results is []
parser.feed(&quot;moo.&quot;);  // parser.results is [&quot;yay!&quot;]
</code></pre>
<p>If there are no possible parsings, and there is no way to “recover” by feeding
more data, then nearley will throw an error whose <code>offset</code> property is the
index of the offending token.</p>
<pre><code class="lang-js">try {
    parser.feed(&quot;Cow goes% moo.&quot;);
} catch(parseError) {
    console.log(&quot;Error at character &quot; + parseError.offset); // &quot;Error at character 9&quot;
}
</code></pre>
<h3 id="tokenizers">Tokenizers</h3>
<p>By default, nearley splits the input into a stream of characters. This is
called <em>scannerless</em> parsing.</p>
<p>A tokenizer splits the input into a stream of larger units called <em>tokens</em>.
This happens in a separate stage before parsing. For example, a tokenizer might
convert <code>512 + 10</code> into <code>[&quot;512&quot;, &quot;+&quot;, &quot;10&quot;]</code>: notice how it removed the
whitespace, and combined multi-digit numbers into a single number.</p>
<p>Using a tokenizer has many benefits. It…</p>
<ul>
<li>…often makes your parser faster by more than an order of magnitude.</li>
<li>…allows you to write cleaner, more maintainable grammars.</li>
<li>…helps avoid ambiguous grammars in some cases. For example, a tokenizer can
easily tell you that <code>superclass</code> is a single keyword, not a sequence of
<code>super</code> and <code>class</code> keywords.</li>
<li>…gives you <em>lexical information</em> such as line numbers for each token. This
lets you make better error messages.</li>
</ul>
<p>nearley supports and recommends <a href="https://github.com/tjvr/moo">Moo</a>, a
super-fast tokenizer. Here is a simple example:</p>
<pre><code class="lang-coffeescript">@{%
const moo = require(&quot;moo&quot;);

const lexer = moo.compile({
  ws:     /[ \t]+/,
  number: /[0-9]+/,
  times:  /\*|x/
});
%}

# Pass your lexer object using the @lexer option:
@lexer lexer

# Use %token to match any token of that type instead of &quot;token&quot;:
multiplication -&gt; %number %ws %times %ws %number {% ([first, , , , second]) =&gt; first * second %}
</code></pre>
<p>Have a look at <a href="https://github.com/tjvr/moo#usage">the Moo documentation</a> to
learn more about the tokenizer.</p>
<p>Note that when using a tokenizer, raw strings match full tokens parsed by Moo.
This is convenient for matching keywords.</p>
<pre><code class="lang-ini">ifStatement -&gt; &quot;if&quot; condition &quot;then&quot; block
</code></pre>
<p>You use the parser as usual: call <code>parser.feed(data)</code>, and nearley will give
you the parsed results in return.</p>
<h2 id="tools">Tools</h2>
<p>As mentioned above, nearley ships with a host of tools.</p>
<h3 id="nearley-test-exploring-a-parser-interactively">nearley-test: Exploring a parser interactively</h3>
<p>A global install of nearley provides <code>nearley-test</code>, a simple command-line tool
you can use to inspect what a parser is doing. You input a generated
<code>grammar.js</code> file, and then give it some input to test the parser against.
<code>nearley-test</code> prints out the output if successful, and optionally
pretty-prints the internal parse table used by the algorithm. This is helpful
to test a new parser.</p>
<h3 id="nearley-unparse-the-unparser">nearley-unparse: The Unparser</h3>
<p>The Unparser takes a (compiled) parser and outputs a random string that would
be accepted by the parser.</p>
<pre><code class="lang-bash">$ nearley-unparse -s number &lt;(nearleyc builtin/prims.ne)
-6.22E94
</code></pre>
<p>You can use the Unparser to…</p>
<ul>
<li>…test your parser specification by generating lots of random expressions
and making sure all of them are “correct”.</li>
<li>…generate random strings from a schema (for example, random email addresses
or telephone numbers).</li>
<li>…create fuzzers and combinatorial stress-testers.</li>
<li>…play “Mad-Libs” automatically! (Practical application: automatic
grammatically valid loremtext.)</li>
</ul>
<p>The Unparser outputs as a stream by continuously writing characters to its
output pipe. So, if it “goes off the deep end” and generates a huge string, you
will still see output scrolling by in real-time.</p>
<p>To limit the size of the output, you can specify a bound on the depth with the
<code>-d</code> flag. This switches the Unparser to a different algorithm. A larger depth
bound corresponds to larger generated strings.</p>
<p>As far as I know, nearley is the only parser generator with this feature. It
is inspired by Roly Fentanes’ <a href="https://fent.github.io/randexp.js/">randexp</a>,
which does the same thing with regular expressions.</p>
<h3 id="nearley-railroad-automagical-railroad-diagrams">nearley-railroad: Automagical Railroad Diagrams</h3>
<p>nearley lets you convert your grammars to pretty SVG railroad diagrams that you
can include in webpages, documentation, and even papers.</p>
<pre><code class="lang-bash">$ nearley-railroad regex.ne -o grammar.html
</code></pre>
<p><img src="/www/railroad-demo.png" alt="Railroad demo"></p>
<p>See a bigger example <a href="http://nearley.js.org/www/railroad-demo.html">here</a>.</p>
<p>(This feature is powered by
<a href="https://github.com/tabatkins/railroad-diagrams"><code>railroad-diagrams</code></a> by
tabatkins.)</p>
<h3 id="other-tools">Other Tools</h3>
<p><em>This section lists nearley tooling created by other developers. These tools
are not distributed with nearley, so if you have problems, please contact the
respective author for support instead of opening an issue with nearley.</em></p>
<p>Atom users can write nearley grammars with <a href="https://github.com/bojidar-bg/nearley-grammar">this
plugin</a> by Bojidar Marinov.</p>
<p>Sublime Text users can write nearley grammars with <a href="https://github.com/liam4/nearley-syntax-sublime">this
syntax</a> by liam4.</p>
<p>Vim users can use <a href="https://github.com/andres-arana/vim-nearley">this plugin</a> by
Andrés Arana.</p>
<p>Visual Studio Code users can use <a href="https://github.com/karyfoundation/nearley-vscode">this
extension</a> by Pouya Kary.</p>
<p>Python users can convert nearley grammars to Python using
<a href="https://github.com/erezsh/lark#how-to-use-nearley-grammars-in-lark">lark</a> by
Erez.</p>
<p>Node users can programmatically access the unparser using
<a href="https://github.com/stolksdorf/nearley-there">nearley-there</a> by Scott
Tolksdorf.</p>
<p>Browser users can use
<a href="https://omrelli.ug/nearley-playground/">nearley-playground</a> by Guillermo
Webster to explore nearley interactively in the browser. There is also a <a href="https://github.com/pmkary/nearley-playground-mac">Mac
app</a> by Pouya Kary.</p>
<p>Webpack users can use
<a href="https://github.com/kozily/nearley-loader">nearley-loader</a> by Andrés Arana to
load grammars directly.</p>
<p>Gulp users can use
<a href="https://github.com/JosephJNK/gulp-nearley">gulp-nearley</a> by Joseph Junker to
compile grammars with a gulpfile.</p>
<h2 id="further-reading">Further reading</h2>
<h3 id="documentation">Documentation</h3>
<ul>
<li><a href="how-to-grammar-good.html">Best practices for writing grammars</a></li>
<li><a href="custom-tokens-and-lexers.html">More on tokenizers</a></li>
<li><a href="accessing-parse-table.html">Accessing the internal parse table</a></li>
<li><a href="using-in-frontend.html">Using <code>nearleyc</code> in browsers</a></li>
</ul>
<h3 id="recipes">Recipes</h3>
<ul>
<li><a href="https://gist.github.com/nathan/d8d1adea38a1ef3a6d6a06552da641aa">Writing an indentation-aware (Python-like) lexer</a></li>
</ul>
<h3 id="blog-posts">Blog posts</h3>
<ul>
<li>Read my <a href="http://hardmath123.github.io/earley.html">blog post</a> to learn more
about the algorithm.</li>
<li>Read about <a href="http://savage.net.au/Marpa.html">Marpa</a> to
learn more than you ever thought you wanted to know about parsing.</li>
<li>A <a href="https://medium.com/@gajus/parsing-absolutely-anything-in-javascript-using-earley-algorithm-886edcc31e5e">nearley
tutorial</a>
written by @gajus.</li>
</ul>

            <div id="footer"><p>nearley is MIT-licensed. It's maintained by <a
            href="http://hardmath123.github.io">Hardmath123</a> (<a
            href="http://github.com/Hardmath123">Github</a>). You're welcome to
            leave questions, comments, advice, or ideas as Github issues. And
            feel free to fork nearley with your own experiments!<br/>
            
            <a href="https://js.org" target="_blank" title="JS.ORG | JavaScript Community">
            <img src="https://logo.js.org/dark_horz.png" width="102" alt="JS.ORG Logo"/></a>
        </div>
    </body>
</html>
