<!DOCTYPE html>
<html>
    <head>
        <title>Writing a parser - nearley.js - JS Parsing Toolkit</title>
        <meta charset="utf-8"/>
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="nearley.js is a simple, fast, and powerful parser toolkit for JavaScript." />
        <link href='https://fonts.googleapis.com/css?family=Roboto:300,700'
              rel='stylesheet' type='text/css'/>
        <link rel="stylesheet" type="text/css" href="/www/main.css"/>
    </head>
    <body class="docs-page">
        <a href="https://github.com/Hardmath123/nearley" class="github-corner"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
        <nav id="nav">
            <ul>
                <li class="page"><a href="/docs/accessing-parse-table">Accessing the parse table</a>
                <li class="page"><a href="/docs/how-to-grammar-good">How to grammar good</a>
                <li class="page"><a href="/docs/glossary">Glossary</a>
                <li class="page"><a href="/docs/index">Getting started</a>
                <li class="page">
                    <a class="page-title-active">Writing a parser</a>
                    <ul>
                        <li class="page-heading"><a href="#vocabulary">Vocabulary</a>
                        <li class="page-heading"><a href="#postprocessors">Postprocessors</a>
                        <li class="page-heading"><a href="#more-syntax-tips-and-tricks">More syntax: tips and tricks</a>
                        <li class="page-heading"><a href="#macros">Macros</a>
                        <li class="page-heading"><a href="#additional-js">Additional JS</a>
                        <li class="page-heading"><a href="#importing-other-grammars">Importing other grammars</a>
                    </ul>
                </li>
                <li class="page"><a href="/docs/usage">Using a parser</a>
                <li class="page"><a href="/docs/tooling">Tooling</a>
                <li class="page"><a href="/docs/tokenizers">Tokenizers</a>
                <li class="page"><a href="/docs/using-in-frontend">Compiling in browsers</a>
            </ul>
        </nav>
        <div id="main" class="center">
            <h1><a href="/">nearley<span style="color: #559;">.js</span><span id="version">2.10.4</span></a></h1>

<h2>Writing a parser</h2>
<h2 id="the-nearley-grammar-language">the nearley grammar language</h2>
<p class="lang-highlight">This section describes the nearley grammar language, in which you can describe
grammars for nearley to parse. Grammars are conventionally kept in <code class="lang-asciidoc"><span class="hljs-title">.ne</span></code> files.
You can then use <code>nearleyc</code> to compile your <code class="lang-asciidoc"><span class="hljs-title">.ne</span></code> grammars to JavaScript
modules.</p>
<p class="lang-highlight">You can find many examples of nearley grammars online, as well as some in the
<code>examples/</code> directory of the <a href="http://github.com/Hardmath123/nearley">Github
repository</a>.</p>
<h3 id="vocabulary">Vocabulary</h3>
<ul>
<li class="lang-highlight">A <em>terminal</em> is a single, constant string or a token. For example, the
keyword <code class="lang-1c"><span class="hljs-string">"if"</span></code> is a terminal.</li>
<li>A <em>nonterminal</em> describes a set of possible strings. For example, all “if”
statements can be described by a single nonterminal whose value depends on
the condition and body of the if statement.</li>
<li class="lang-highlight">A <em>rule</em> (or production rule) is a definition of a nonterminal. For example,<pre class="lang-highlight"><code class="lang-js">ifStatement -&gt; <span class="hljs-string">"if"</span> condition <span class="hljs-string">"then"</span> statement <span class="hljs-string">"endif"</span>
</code></pre>
is the rule according to which the if statement nonterminal, <code class="lang-bash"><span class="hljs-keyword">if</span>Statement</code>,
is parsed. It depends on the nonterminals <code class="lang-mel"><span class="hljs-keyword">condition</span></code> and <code>statement</code>. A
nonterminal can be described by multiple rules. For example, we can add a
second rule<pre class="lang-highlight"><code class="lang-js">ifStatement -&gt; <span class="hljs-string">"if"</span> condition <span class="hljs-string">"then"</span> statement <span class="hljs-string">"else"</span> statement <span class="hljs-string">"endif"</span>
</code></pre>
to support “else” clauses.</li>
</ul>
<p class="lang-highlight">By default, nearley attempts to parse the first nonterminal defined in the
grammar. In the following grammar, nearley will try to parse input text as an
<code class="lang-mel"><span class="hljs-keyword">expression</span></code>.</p>
<pre class="lang-highlight"><code class="lang-js">expression -&gt; number <span class="hljs-string">"+"</span> number
expression -&gt; number <span class="hljs-string">"-"</span> number
expression -&gt; number <span class="hljs-string">"*"</span> number
expression -&gt; number <span class="hljs-string">"/"</span> number
number -&gt; [<span class="hljs-number">0</span>-<span class="hljs-number">9</span>]:+
</code></pre>
<p class="lang-highlight">You can use the pipe character <code class="lang-1c"><span class="hljs-string">|</span></code> to separate alternative rules for a
nonterminal. In the example below, <code class="lang-mel"><span class="hljs-keyword">expression</span></code> has four different rules.</p>
<pre class="lang-highlight"><code class="lang-js">expression -&gt;
      number <span class="hljs-string">"+"</span> number
    | number <span class="hljs-string">"-"</span> number
    | number <span class="hljs-string">"*"</span> number
    | number <span class="hljs-string">"/"</span> number
</code></pre>
<p class="lang-highlight">The keyword <code class="lang-actionscript"><span class="hljs-literal">null</span></code> stands for the <strong>epsilon rule</strong>, which matches nothing. The
following nonterminal matches zero or more <code>cow</code>s in a row, such as
<code>cowcowcow</code>:</p>
<pre class="lang-highlight"><code class="lang-js">a -&gt; <span class="hljs-literal">null</span> | a <span class="hljs-string">"cow"</span>
</code></pre>
<h3 id="postprocessors">Postprocessors</h3>
<p class="lang-highlight">By default, nearley wraps everything matched by a rule into an array. For
example, when <code class="lang-crmsh"><span class="hljs-keyword">rule</span> -&gt; <span class="hljs-string">"foo"</span> <span class="hljs-string">"bar"</span></code> matches, it creates the “parse tree”
<code class="lang-json">[<span class="hljs-string">"foo"</span>, <span class="hljs-string">"bar"</span>]</code>.  Most of the time, however, you need to process that data in
some way: for example, you may want to filter out whitespace, or transform the
results into a custom JavaScript object.</p>
<p class="lang-highlight">For this purpose, each rule can have a <em>postprocessor</em>: a JavaScript function
that transforms the array and returns a “processed” version of the result.
Postprocessors are wrapped in <code class="lang-gcode">{<span class="hljs-preprocessor">%</span> <span class="hljs-preprocessor">%</span>}</code>:</p>
<pre class="lang-highlight"><code class="lang-js">expression -&gt; number <span class="hljs-string">"+"</span> number {%
    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data, location, reject</span>) </span>{
        <span class="hljs-keyword">return</span> {
            operator: <span class="hljs-string">"sum"</span>,
            leftOperand: data[<span class="hljs-number">0</span>],
            rightOperand: data[<span class="hljs-number">2</span>] <span class="hljs-comment">// data[1] is "+"</span>
        };
    }
%}
</code></pre>
<p class="lang-highlight">The rule above will parse the string <code class="lang-cpp"><span class="hljs-number">5</span>+<span class="hljs-number">10</span></code> into <code class="lang-css"><span class="hljs-rules">{ <span class="hljs-rule"><span class="hljs-attribute">operator</span>:<span class="hljs-value"> <span class="hljs-string">"sum"</span>,
leftOperand: <span class="hljs-string">"5"</span>, rightOperand: <span class="hljs-string">"10"</span> </span></span></span>}</code>.</p>
<p>The postprocessor can be any function. It will be passed three arguments:</p>
<ul>
<li class="lang-highlight"><code class="lang-haskell"><span class="hljs-typedef"><span class="hljs-keyword">data</span>: <span class="hljs-type">Array</span></span></code> - an array that contains the results of parsing each part of
the rule. Note that it is still an array, even if the rule only has one part!
You can use the built-in <code class="lang-gcode">{<span class="hljs-preprocessor">%</span> id <span class="hljs-preprocessor">%</span>}</code> postprocessor to convert a one-item array
into the item itself.</li>
<li class="lang-highlight"><code class="lang-http"><span class="hljs-attribute">location</span>: <span class="hljs-string">number</span></code> - the index (zero-based) at which the rule match starts.
This is useful, for example, to construct an error message that tells you where
in the source the error occurred.</li>
<li class="lang-highlight"><code class="lang-http"><span class="hljs-attribute">reject</span>: <span class="hljs-string">Object</span></code> - return this object to signal that this rule doesn’t
<em>actually</em> match. This is necessary in certain edge-conditions. For example,
suppose you want sequences of letters to match variables, except for the
keyword <code class="lang-actionscript"><span class="hljs-keyword">var</span></code>. In this case, your rule may be<pre class="lang-highlight"><code class="lang-js">word -&gt; [a-z]:+ {%
    <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">d,l, reject</span>) </span>{
        <span class="hljs-keyword">if</span> (d[<span class="hljs-number">0</span>] == <span class="hljs-string">'var'</span>) {
            <span class="hljs-keyword">return</span> reject;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-keyword">return</span> {<span class="hljs-string">'var'</span>: d[<span class="hljs-number">0</span>]};
        }
    }
%}
</code></pre>
Please note that grammars using <code class="lang-vhdl"><span class="hljs-keyword">reject</span></code> are not context-free, and are often
much slower to parse. Use it wisely! You can usually avoid the need for
<code class="lang-vhdl"><span class="hljs-keyword">reject</span></code> by using a <a href="#tokenizers">tokenizer</a>.</li>
</ul>
<p>Remember that a postprocessor is scoped to a single rule, not the whole
nonterminal. If a nonterminal has multiple alternative rules, each of them can
have its own postprocessor.</p>
<p class="lang-highlight">For arrow-function users, a convenient pattern is to decompose the <code class="lang-haskell"><span class="hljs-typedef"><span class="hljs-keyword">data</span></span></code> array
within the argument of the arrow function:</p>
<pre class="lang-highlight"><code class="lang-js">expression -&gt;
      number <span class="hljs-string">"+"</span> number {% ([first, _, second]) =&gt; first + second %}
    | number <span class="hljs-string">"-"</span> number {% ([first, _, second]) =&gt; first - second %}
    | number <span class="hljs-string">"*"</span> number {% ([first, _, second]) =&gt; first * second %}
    | number <span class="hljs-string">"/"</span> number {% ([first, _, second]) =&gt; first / second %}
</code></pre>
<p>There are two built-in postprocessors for the most common scenarios:</p>
<ul>
<li class="lang-highlight"><code class="lang-applescript"><span class="hljs-property">id</span></code> - returns the first element of the <code class="lang-haskell"><span class="hljs-typedef"><span class="hljs-keyword">data</span></span></code> array. This is useful to
extract the content of a single-element array: <code class="lang-erlang-repl"><span class="hljs-function_or_atom">foo</span> <span class="hljs-arrow">-&gt;</span> <span class="hljs-function_or_atom">bar</span> {<span class="hljs-comment">% id %}</span></code></li>
<li class="lang-highlight"><code>nuller</code> - returns null. This is useful for whitespace rules: <code class="lang-erlang-repl"><span class="hljs-function_or_atom">space</span> <span class="hljs-arrow">-&gt;</span> <span class="hljs-string">" "</span>
{<span class="hljs-comment">% nuller %}</span></code></li>
</ul>
<h4 id="target-languages">Target languages</h4>
<p class="lang-highlight">By default, <code>nearleyc</code> compiles your grammar to JavaScript. You can also choose
CoffeeScript or TypeScript by adding <code class="lang-aspectj"><span class="hljs-annotation">@preprocessor</span> coffee</code> or <code class="lang-aspectj"><span class="hljs-annotation">@preprocessor</span>
typescript</code> at the top of your grammar file. This can be useful to write your
postprocessors in a different language, and to get type annotations if you wish
to use nearley in a statically typed dialect of JavaScript.</p>
<h3 id="more-syntax-tips-and-tricks">More syntax: tips and tricks</h3>
<h4 id="comments">Comments</h4>
<p class="lang-highlight">Comments are marked with ‘#’. Everything from <code class="lang-vala"><span class="hljs-preprocessor">#</span></code> to the end of a line is
ignored:</p>
<pre class="lang-highlight"><code class="lang-ini">expression -&gt; number "+" number <span class="hljs-comment"># sum of two numbers</span>
</code></pre>
<h4 id="charsets">Charsets</h4>
<p>You can use valid RegExp charsets in a rule (unless you’re using a
<a href="#tokenizers">tokenizer</a>):</p>
<pre class="lang-highlight"><code class="lang-autohotkey">not_<span class="hljs-built_in">a_letter</span> -&gt; [^<span class="hljs-literal">a</span>-zA-Z]
</code></pre><p class="lang-highlight">The <code class="lang-erlang">.</code> character can be used to represent any character.</p>
<h4 id="case-insensitive-string-literals">Case-insensitive string literals</h4>
<p class="lang-highlight">You can create case-insensitive string literals by adding an <code class="lang-matlab"><span class="hljs-built_in">i</span></code> after the
string literal:</p>
<pre class="lang-highlight"><code class="lang-elixir">cow -&gt; <span class="hljs-string">"cow"</span>i <span class="hljs-comment"># matches CoW, COW, and so on.</span>
</code></pre><p class="lang-highlight">Note that if you are using a lexer, your lexer should use the <code class="lang-matlab"><span class="hljs-built_in">i</span></code> flag in its
regexes instead. That is, if you are using a lexer, you should <em>not</em> use the
<code class="lang-matlab"><span class="hljs-built_in">i</span></code> suffix in nearley.</p>
<h4 id="ebnf">EBNF</h4>
<p class="lang-highlight">nearley supports the <code class="lang-gherkin"><span class="hljs-keyword">*</span></code>, <code>?</code>, and <code class="lang-diff"><span class="hljs-addition">+</span></code> operators from
<a href="https://en.wikipedia.org/wiki/Extended_Backus–Naur_form">EBNF</a> as shown:</p>
<pre class="lang-highlight"><code class="lang-ini">batman -&gt; "na":* "batman" <span class="hljs-comment"># nananana...nanabatman</span>
</code></pre>
<p>You can also use capture groups with parentheses. Its contents can be anything
that a rule can have:</p>
<pre class="lang-highlight"><code class="lang-js">banana -&gt; <span class="hljs-string">"ba"</span> (<span class="hljs-string">"na"</span> {% id %} | <span class="hljs-string">"NA"</span> {% id %}):+
</code></pre>
<h3 id="macros">Macros</h3>
<p>Macros allow you to create polymorphic rules:</p>
<pre class="lang-highlight"><code class="lang-ini"><span class="hljs-comment"># Matches "'Hello?' 'Hello?' 'Hello?'"</span>
main -&gt; matchThree<span class="hljs-title">[inQuotes["Hello?"]]</span>

matchThree<span class="hljs-title">[X]</span> -&gt; $X " " $X " " $X

inQuotes<span class="hljs-title">[X]</span> -&gt; "'" $X "'"
</code></pre>
<p>Macros are dynamically scoped, which means they see arguments passed to parent
macros:</p>
<pre class="lang-highlight"><code class="lang-ini"><span class="hljs-comment"># Matches "Cows oink." and "Cows moo!"</span>
main -&gt; sentence<span class="hljs-title">["Cows", ("." | "!")]</span>

sentence<span class="hljs-title">[ANIMAL, PUNCTUATION]</span> -&gt; animalGoes<span class="hljs-title">[("moo" | "oink" | "baa")]</span> $PUNCTUATION

animalGoes<span class="hljs-title">[SOUND]</span> -&gt; $ANIMAL " " $SOUND <span class="hljs-comment"># uses $ANIMAL from its caller</span>
</code></pre>
<p class="lang-highlight">Macros are expanded at compile time and inserted in places they are used. They
are not “real” rules. Therefore, macros <em>cannot</em> be recursive (<code>nearleyc</code> will
go into an infinite loop trying to expand the macro-loop).</p>
<h3 id="additional-js">Additional JS</h3>
<p class="lang-highlight">For more intricate postprocessors, or any other functionality you may need, you
can include chunks of JavaScript code between production rules by surrounding
it with <code class="lang-gcode">@{<span class="hljs-preprocessor">%</span> ... <span class="hljs-preprocessor">%</span>}</code>:</p>
<pre class="lang-highlight"><code class="lang-js">@{%
<span class="hljs-keyword">const</span> cowSays = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./cow.js"</span>);
%}

cow -&gt; <span class="hljs-string">"moo"</span> {% ([moo]) =&gt; cowSays(moo) %}
</code></pre>
<p>Note that it doesn’t matter where you add these; they all get hoisted to the
top of the generated code.</p>
<h3 id="importing-other-grammars">Importing other grammars</h3>
<p>You can include the content of other grammar files:</p>
<pre class="lang-highlight"><code class="lang-ini">@include "../misc/primitives.ne" <span class="hljs-comment"># path relative to file being compiled</span>
sum -&gt; number "+" number <span class="hljs-comment"># uses "number" from the included file</span>
</code></pre>
<p>There are several builtin helper files that you can include:</p>
<pre class="lang-highlight"><code class="lang-ini">@builtin "cow.ne"
main -&gt; cow:+
</code></pre>
<p>See the <a href="builtin" class="lang-highlight"><code class="lang-bash"><span class="hljs-built_in">builtin</span>/</code></a> directory for more details. Contributions are
welcome!</p>
<p>Including a file imports <em>all</em> of the nonterminals defined in it, as well as
any JS, macros, and configuration options defined there.</p>


            <div id="footer"><p>nearley is MIT-licensed. It's maintained by <a
            href="http://hardmath123.github.io">Hardmath123</a> (<a
            href="http://github.com/Hardmath123">Github</a>). You're welcome to
            leave questions, comments, advice, or ideas as Github issues. And
            feel free to fork nearley with your own experiments!<br/>
            
            <a href="https://js.org" target="_blank" title="JS.ORG | JavaScript Community">
            <img src="https://logo.js.org/dark_horz.png" width="102" alt="JS.ORG Logo"/></a>
        </div>
    </body>
</html>
